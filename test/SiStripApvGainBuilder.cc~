// system include files
#include <memory>

// user include files

#include "CondCore/DBOutputService/interface/PoolDBOutputService.h"
#include "CondFormats/SiStripObjects/interface/SiStripGain.h"

#include "Geometry/TrackerGeometryBuilder/interface/TrackerGeometry.h" 
#include "Geometry/Records/interface/TrackerDigiGeometryRecord.h"
#include "Geometry/CommonDetUnit/interface/GeomDetUnit.h"
#include "Geometry/CommonDetUnit/interface/GeomDetType.h"
#include "Geometry/CommonTopologies/interface/StripTopology.h"
#include "Geometry/TrackerGeometryBuilder/interface/StripGeomDetUnit.h"
#include "Geometry/TrackerGeometryBuilder/interface/StripGeomDetType.h"
#include "DataFormats/FEDRawData/interface/FEDNumbering.h"


#include "CLHEP/Random/RandFlat.h"
#include "CLHEP/Random/RandGauss.h"



#include "CondTools/SiStrip/test/SiStripGainBuilder.h"

using namespace std;
using namespace cms;

SiStripGainBuilder::SiStripGainBuilder( const edm::ParameterSet& iConfig ):
  printdebug_(iConfig.getUntrackedParameter<bool>("printDebug",false)){};


void SiStripGainBuilder::beginJob( const edm::EventSetup& iSetup ) {

  edm::ESHandle<TrackerGeometry> pDD;
  iSetup.get<TrackerDigiGeometryRecord>().get( pDD );     
  edm::LogInfo("SiStripGainBuilder") <<" There are "<<pDD->detUnits().size() <<" detectors"<<std::endl;
  
  for(TrackerGeometry::DetUnitContainer::const_iterator it = pDD->detUnits().begin(); it != pDD->detUnits().end(); it++){
  
    if( dynamic_cast<StripGeomDetUnit*>((*it))!=0){
      uint32_t detid=((*it)->geographicalId()).rawId();            
      const StripTopology& p = dynamic_cast<StripGeomDetUnit*>((*it))->specificTopology();
      unsigned short NAPVPairs = p.nstrips()/256;
      if(NAPVPairs<2 || NAPVPairs>3 ) {
	edm::LogError("SiStripGainBuilder")<<" Problem with Number of strips in detector.. "<< p.nstrips() <<" Exiting program"<<endl;
	exit(1);
      }
      detid_apvs.push_back( pair<uint32_t,unsigned short>(detid,NAPVPairs) );
      if (printdebug_)
	edm::LogInfo("SiStripGainBuilder")<< "detid " << detid << " apvpairs " << NAPVPairs;
    }
  }
}

void SiStripGainBuilder::analyze(const edm::Event& evt, const edm::EventSetup& iSetup){

  unsigned int run=evt.id().run();

  edm::LogInfo("SiStripGainBuilder") << "... creating dummy SiStripGain Data for Run " << run << "\n " << std::endl;

  SiStripGain* SiStripGain_ = new SiStripGain();

  for(std::vector< pair<uint32_t,unsigned short> >::const_iterator it = detid_apvs.begin(); it != detid_apvs.end(); it++){
    //Generate Noise for det detid
    std::vector<short> theSiStripVector;
    for(unsigned short j=0; j<it->second; j++){
      uint16_t gain= (j+1)*1000+(int) (RandFlat::shoot(1.)*100);
	if (printdebug_)
	  edm::LogInfo("SiStripGainBuilder") << "detid " << it->first << " \t"
					     << " apv " << j << " \t"
					       << gain    << " \t" 
					       << std::endl; 	    
	theSiStripVector.push_back(gain);
    }
  	    
      
    SiStripGain::Range range(theSiStripVector.begin(),theSiStripVector.end());
    if ( ! SiStripGain_->put(it->first,range) )
      edm::LogError("SiStripGainBuilder")<<"[SiStripGainBuilder::analyze] detid already exists"<<std::endl;
  }

  
  //End now write sistripnoises data in DB
  edm::Service<cond::service::PoolDBOutputService> mydbservice;
  
  if( mydbservice.isAvailable() ){
    try{
      size_t callbackToken=mydbservice->callbackToken("SiStripGain");
      edm::LogInfo("SiStripGainBuilder")<<"current time "<<mydbservice->currentTime() << " callbackToken " << callbackToken <<std::endl;
      //mydbservice->newValidityForNewPayload<SiStripGain>(SiStripGain_,mydbservice->currentTime(),callbackToken);      
      mydbservice->newValidityForNewPayload<SiStripGain>(SiStripGain_,mydbservice->endOfTime(),callbackToken);      
    }catch(const cond::Exception& er){
      edm::LogError("SiStripGainBuilder")<<er.what()<<std::endl;
    }catch(const std::exception& er){
      edm::LogError("SiStripGainBuilder")<<"caught std::exception "<<er.what()<<std::endl;
    }catch(...){
      edm::LogError("SiStripGainBuilder")<<"Funny error"<<std::endl;
    }
  }else{
    edm::LogError("SiStripGainBuilder")<<"Service is unavailable"<<std::endl;
  }
}
     
